/**
 * V2 System Adapter
 * ResultsInsightsPanelV2와 이벤트 버스 간의 어댑터
 */

import { CentralEventBus } from '../EventBus';
import type {
  V2Event,
  V2ScenarioSavedEvent,
  V2KPIUpdatedEvent,
  V2RecommendationEvent,
  EventHandler
} from '../types';
import type { AxisKey } from '../../../types/buildup.types';

export interface V2AdapterConfig {
  autoSyncScenarios: boolean;
  autoSyncKPIUpdates: boolean;
  autoSyncRecommendations: boolean;
}

export class V2SystemAdapter {
  private eventBus: CentralEventBus;
  private subscriptions: string[] = [];
  private config: V2AdapterConfig;

  constructor(config: V2AdapterConfig = {
    autoSyncScenarios: true,
    autoSyncKPIUpdates: true,
    autoSyncRecommendations: true
  }) {
    this.eventBus = CentralEventBus.getInstance();
    this.config = config;
    this.setupSubscriptions();
  }

  private setupSubscriptions(): void {
    // V2에서 발생하는 이벤트들 구독
    this.subscriptions = [
      this.eventBus.subscribe('v2:scenario:saved', this.handleScenarioSaved.bind(this), 1),
      this.eventBus.subscribe('v2:kpi:updated', this.handleKPIUpdated.bind(this), 1),
      this.eventBus.subscribe('v2:recommendation:generated', this.handleRecommendationGenerated.bind(this), 2),
      this.eventBus.subscribe('v2:simulation:completed', this.handleSimulationCompleted.bind(this), 2),
      this.eventBus.subscribe('v2:scenario:shared', this.handleScenarioShared.bind(this), 3),
    ];
  }

  /**
   * V2에서 시나리오 저장 시 다른 시스템으로 전파
   */
  private async handleScenarioSaved(event: V2ScenarioSavedEvent): Promise<void> {
    console.log('[V2Adapter] Processing scenario saved:', event);

    if (!this.config.autoSyncScenarios) return;

    const { scenarioId, name, projectedScores, keyActions, timeline, priority } = event.data;

    // 캘린더 이벤트 생성을 위한 이벤트 발행
    await this.eventBus.emit({
      type: 'calendar:auto-generate:scenario',
      source: 'v2-auto',
      userId: event.userId,
      data: {
        scenarioId,
        scenarioName: name,
        keyActions,
        timeline,
        priority,
        estimatedMilestones: this.generateMilestonesFromActions(keyActions, timeline)
      },
      metadata: {
        originalEvent: event.id,
        autoGenerated: true
      }
    });

    // Buildup 프로젝트 생성을 위한 이벤트 발행
    if (priority === 'high' && keyActions.length > 0) {
      await this.eventBus.emit({
        type: 'buildup:auto-generate:project',
        source: 'v2-auto',
        userId: event.userId,
        data: {
          scenarioId,
          projectName: `${name} 실행 프로젝트`,
          keyActions,
          priority,
          expectedKPIImpact: this.calculateKPIImpactDifference(projectedScores),
          timeline
        },
        metadata: {
          originalEvent: event.id,
          autoGenerated: true
        }
      });
    }

    // 팀 알림 발행 (협업 시나리오인 경우)
    if (event.data.tags?.includes('collaboration')) {
      await this.eventBus.emit({
        type: 'notification:team:scenario-created',
        source: 'v2-auto',
        userId: event.userId,
        data: {
          scenarioId,
          scenarioName: name,
          projectedImpact: this.summarizeProjectedImpact(projectedScores),
          priority,
          requiresReview: priority === 'high'
        }
      });
    }
  }

  /**
   * KPI 업데이트 시 다른 시스템 동기화
   */
  private async handleKPIUpdated(event: V2KPIUpdatedEvent): Promise<void> {
    console.log('[V2Adapter] Processing KPI update:', event);

    if (!this.config.autoSyncKPIUpdates) return;

    const { previousScores, currentScores, changes, triggers, confidence } = event.data;

    // 중요한 변화가 있는 경우 알림
    const significantChanges = Object.entries(changes).filter(([_, change]) => Math.abs(change) >= 5);

    if (significantChanges.length > 0) {
      await this.eventBus.emit({
        type: 'notification:kpi:significant-change',
        source: 'v2-auto',
        userId: event.userId,
        data: {
          changes: significantChanges.reduce((acc, [axis, change]) => {
            acc[axis as AxisKey] = change;
            return acc;
          }, {} as Record<AxisKey, number>),
          triggers,
          confidence,
          previousScores,
          currentScores
        },
        metadata: {
          originalEvent: event.id,
          severity: this.calculateChangeSeverity(changes)
        }
      });
    }

    // 기존 시나리오들의 유효성 재검토 이벤트
    await this.eventBus.emit({
      type: 'v2:scenarios:revalidate',
      source: 'v2-auto',
      userId: event.userId,
      data: {
        newBaselineScores: currentScores,
        changeContext: triggers,
        confidence
      },
      metadata: {
        originalEvent: event.id
      }
    });
  }

  /**
   * AI 추천사항 생성 시 처리
   */
  private async handleRecommendationGenerated(event: V2RecommendationEvent): Promise<void> {
    console.log('[V2Adapter] Processing recommendation generated:', event);

    if (!this.config.autoSyncRecommendations) return;

    const { recommendations, targetAxis, context } = event.data;

    // 고우선순위 추천사항을 액션 아이템으로 변환
    const highPriorityRecs = recommendations.filter(rec => rec.priority === 'high');

    for (const recommendation of highPriorityRecs) {
      // 즉시 실행 가능한 추천사항은 캘린더에 일정 추가
      if (recommendation.timeframe === 'immediate') {
        await this.eventBus.emit({
          type: 'calendar:auto-generate:action-item',
          source: 'v2-auto',
          userId: event.userId,
          data: {
            title: recommendation.title,
            description: recommendation.description,
            actionItems: recommendation.actionItems,
            targetAxis,
            expectedImpact: recommendation.expectedImpact,
            urgency: 'immediate',
            estimatedEffort: recommendation.estimatedEffort
          },
          metadata: {
            originalEvent: event.id,
            recommendationId: `rec_${Date.now()}`
          }
        });
      }

      // 중장기 추천사항은 프로젝트로 변환
      if (['medium', 'long'].includes(recommendation.timeframe) && recommendation.estimatedEffort >= 5) {
        await this.eventBus.emit({
          type: 'buildup:auto-generate:project',
          source: 'v2-auto',
          userId: event.userId,
          data: {
            projectName: recommendation.title,
            description: recommendation.description,
            keyActions: recommendation.actionItems,
            priority: recommendation.priority,
            expectedKPIImpact: recommendation.expectedImpact,
            timeline: recommendation.timeframe,
            estimatedEffort: recommendation.estimatedEffort
          },
          metadata: {
            originalEvent: event.id,
            recommendationId: `rec_${Date.now()}`
          }
        });
      }
    }

    // 추천사항 요약 알림
    await this.eventBus.emit({
      type: 'notification:recommendations:summary',
      source: 'v2-auto',
      userId: event.userId,
      data: {
        totalRecommendations: recommendations.length,
        highPriorityCount: highPriorityRecs.length,
        targetAxis,
        context,
        topRecommendation: recommendations[0]
      }
    });
  }

  /**
   * 시뮬레이션 완료 시 처리
   */
  private async handleSimulationCompleted(event: V2Event): Promise<void> {
    console.log('[V2Adapter] Processing simulation completed:', event);

    // 시뮬레이션 결과를 분석하여 새로운 인사이트 생성
    // 예: 시뮬레이션 결과가 현실과 많이 다른 경우 모델 재조정 필요 알림
  }

  /**
   * 시나리오 공유 시 처리
   */
  private async handleScenarioShared(event: V2Event): Promise<void> {
    console.log('[V2Adapter] Processing scenario shared:', event);

    // 협업 관련 알림 및 워크플로 트리거
  }

  /**
   * 유틸리티 메서드들
   */
  private generateMilestonesFromActions(actions: string[], timeline: string): Array<{
    name: string;
    estimatedDays: number;
    dependencies?: string[];
  }> {
    const timelineMap = {
      '1주': 7,
      '2주': 14,
      '1개월': 30,
      '2개월': 60,
      '3개월': 90,
      '6개월': 180
    };

    const totalDays = timelineMap[timeline as keyof typeof timelineMap] || 30;
    const daysPerAction = Math.floor(totalDays / actions.length);

    return actions.map((action, index) => ({
      name: action,
      estimatedDays: daysPerAction * (index + 1),
      dependencies: index > 0 ? [actions[index - 1]] : undefined
    }));
  }

  private calculateKPIImpactDifference(projectedScores: Record<AxisKey, number>): Partial<Record<AxisKey, number>> {
    // 현재 점수와 예상 점수의 차이 계산
    // 실제 구현에서는 현재 V2 스토어에서 현재 점수를 가져와야 함
    const mockCurrentScores: Record<AxisKey, number> = {
      GO: 65, EC: 70, PT: 75, PF: 68, TO: 72
    };

    const impact: Partial<Record<AxisKey, number>> = {};
    Object.entries(projectedScores).forEach(([axis, projectedScore]) => {
      const currentScore = mockCurrentScores[axis as AxisKey];
      const difference = projectedScore - currentScore;
      if (Math.abs(difference) >= 2) { // 2점 이상 차이나는 경우만
        impact[axis as AxisKey] = difference;
      }
    });

    return impact;
  }

  private summarizeProjectedImpact(projectedScores: Record<AxisKey, number>): string {
    const improvements = [];
    const concerns = [];

    Object.entries(projectedScores).forEach(([axis, score]) => {
      if (score >= 80) {
        improvements.push(`${axis}: ${score}점`);
      } else if (score < 60) {
        concerns.push(`${axis}: ${score}점`);
      }
    });

    let summary = '';
    if (improvements.length > 0) {
      summary += `개선 예상: ${improvements.join(', ')}`;
    }
    if (concerns.length > 0) {
      if (summary) summary += ' / ';
      summary += `주의 필요: ${concerns.join(', ')}`;
    }

    return summary || '전반적으로 안정적인 시나리오';
  }

  private calculateChangeSeverity(changes: Record<AxisKey, number>): 'low' | 'medium' | 'high' | 'critical' {
    const maxChange = Math.max(...Object.values(changes).map(Math.abs));

    if (maxChange >= 20) return 'critical';
    if (maxChange >= 10) return 'high';
    if (maxChange >= 5) return 'medium';
    return 'low';
  }

  /**
   * V2에서 이벤트를 발행하는 메서드들 (V2 컴포넌트에서 호출)
   */
  async emitScenarioSaved(scenarioData: {
    scenarioId: string;
    name: string;
    projectedScores: Record<AxisKey, number>;
    keyActions: string[];
    timeline: string;
    priority: 'high' | 'medium' | 'low';
    estimatedEffort: number;
    expectedROI: number;
    tags: string[];
  }, userId?: string): Promise<void> {
    const event: V2ScenarioSavedEvent = {
      id: '',
      type: 'v2:scenario:saved',
      source: 'v2-manual',
      timestamp: 0,
      userId,
      data: scenarioData
    };

    await this.eventBus.emit(event);
  }

  async emitKPIUpdated(kpiData: {
    previousScores: Record<AxisKey, number>;
    currentScores: Record<AxisKey, number>;
    changes: Record<AxisKey, number>;
    triggers: string[];
    confidence: number;
  }, userId?: string): Promise<void> {
    const event: V2KPIUpdatedEvent = {
      id: '',
      type: 'v2:kpi:updated',
      source: 'v2-auto',
      timestamp: 0,
      userId,
      data: kpiData
    };

    await this.eventBus.emit(event);
  }

  /**
   * 정리
   */
  dispose(): void {
    this.subscriptions.forEach(subId => {
      this.eventBus.unsubscribe(subId);
    });
    this.subscriptions = [];
  }
}