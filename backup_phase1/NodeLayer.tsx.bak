/**
 * @fileoverview ì¸í„°ë™í‹°ë¸Œ ë…¸ë“œ ë ˆì´ì–´
 * @description ë¸Œëœì¹˜ ëì˜ í”¼ë“œ ë…¸ë“œë“¤ê³¼ ì¸í„°ë™ì…˜ ì²˜ë¦¬
 * @author PocketCompany
 * @since 2025-01-20
 */

import React, { useMemo, useCallback, useRef, useEffect } from 'react';
import type { FeedItem } from '../../types/timeline.types';
import type {
  StagePosition,
  BranchInteractionEvent,
  FeedItemWithPosition
} from '../../types/branch-timeline.types';
import type { ProjectPhase } from '../../types/buildup.types';
import { BRANCH_CONFIGURATIONS } from '../../config/branchPositions';

interface NodeLayerProps {
  /** í”¼ë“œ ë°ì´í„° */
  feeds: FeedItem[];
  /** ìœ„ì¹˜ê°€ ê³„ì‚°ëœ í”¼ë“œ ë°ì´í„° */
  positionedFeeds: FeedItemWithPosition[];
  /** ë¸Œëœì¹˜ ì‹œì‘ì ë“¤ */
  branchStartPoints: Record<ProjectPhase, { x: number; y: number }>;
  /** ë·°í¬íŠ¸ ìƒíƒœ */
  viewportState: {
    width: number;
    height: number;
    scrollTop: number;
    scrollLeft: number;
  };
  /** ë‹¨ê³„ ìœ„ì¹˜ ì •ë³´ */
  stagePositions: Record<ProjectPhase, StagePosition>;
  /** í”¼ë“œ ì¸í„°ë™ì…˜ í•¸ë“¤ëŸ¬ */
  onFeedInteraction: (event: BranchInteractionEvent) => void;
  /** ì»¨í…Œì´ë„ˆ ì°¸ì¡° */
  containerRef: React.RefObject<HTMLDivElement>;
  /** í˜¸ë²„ëœ í”¼ë“œ ID */
  hoveredFeedId: string | null;
  /** ì„ íƒëœ í”¼ë“œ ID */
  selectedFeedId: string | null;
  /** í™•ì¥ëœ í”¼ë“œ IDs */
  expandedFeedIds: Set<string>;
}

/**
 * ì¸í„°ë™í‹°ë¸Œ ë…¸ë“œ ë ˆì´ì–´
 * ë¸Œëœì¹˜ ëì— ìœ„ì¹˜í•œ í”¼ë“œ ë…¸ë“œë“¤ì˜ ë Œë”ë§ê³¼ ì¸í„°ë™ì…˜ ê´€ë¦¬
 */
const NodeLayer: React.FC<NodeLayerProps> = ({
  feeds,
  positionedFeeds,
  branchStartPoints,
  viewportState,
  stagePositions,
  onFeedInteraction,
  containerRef,
  hoveredFeedId,
  selectedFeedId,
  expandedFeedIds
}) => {

  // ì»´í¬ë„ŒíŠ¸ ë¦¬ë Œë”ë§ ì¶”ì 
  const renderCount = useRef(0);
  const prevFeedsCount = useRef(positionedFeeds.length);

  useEffect(() => {
    renderCount.current++;
    console.log('ğŸ¨ NodeLayer ë Œë”ë§:', {
      renderCount: renderCount.current,
      positionedFeedsCount: positionedFeeds.length,
      feedsFromProps: feeds.length,
      feedsChanged: prevFeedsCount.current !== positionedFeeds.length,
      timestamp: new Date().toISOString()
    });

    prevFeedsCount.current = positionedFeeds.length;
  });

  // í˜„ì¬ ë·°í¬íŠ¸ì— ë³´ì´ëŠ” ë…¸ë“œë“¤ë§Œ ê³„ì‚°
  const visibleNodes: FeedItemWithPosition[] = useMemo(() => {
    // ë””ë²„ê¹…: feedsWithPositions í™•ì¸
    console.log('ğŸ” NodeLayer - positionedFeeds:', {
      count: positionedFeeds.length,
      feeds: positionedFeeds,
      stagePositions: stagePositions,
      rawFeeds: feeds
    });

    // Propsì—ì„œ ë°›ì€ ìœ„ì¹˜ ë°ì´í„° ì‚¬ìš©
    if (positionedFeeds.length > 0) {
      console.log('âœ… Propsì—ì„œ ìœ„ì¹˜ ë°ì´í„° ì‚¬ìš©:', {
        count: positionedFeeds.length,
        firstNode: positionedFeeds[0]?.branchPosition,
        allPositions: positionedFeeds.map(f => ({
          title: f.title,
          x: f.branchPosition.x,
          y: f.branchPosition.y
        }))
      });
    } else if (feeds.length > 0) {
      console.warn('âš ï¸ ìœ„ì¹˜ ë°ì´í„°ê°€ ì—†ìŒ. feeds:', feeds.length);
    }

    const { scrollTop, height } = viewportState;
    const viewportStart = scrollTop - 100; // ì˜¤ë²„ìŠ¤ìº”
    const viewportEnd = scrollTop + height + 100;

    // ë””ë²„ê¹…: ë·°í¬íŠ¸ ë° ë…¸ë“œ ìœ„ì¹˜ í™•ì¸
    console.log('ğŸ“ ë·°í¬íŠ¸ ê³„ì‚°:', {
      scrollTop,
      height,
      viewportStart,
      viewportEnd,
      firstNodeY: positionedFeeds[0]?.branchPosition?.y,
      lastNodeY: positionedFeeds[positionedFeeds.length - 1]?.branchPosition?.y
    });

    // ë·°í¬íŠ¸ ë‚´ ë…¸ë“œ í•„í„°ë§ - ì¼ì‹œì ìœ¼ë¡œ ëª¨ë“  ë…¸ë“œ í‘œì‹œ (ë””ë²„ê¹…)
    const visible = positionedFeeds; // ëª¨ë“  ë…¸ë“œ í‘œì‹œí•˜ì—¬ ìœ„ì¹˜ í™•ì¸

    console.log('ğŸ” ë…¸ë“œ ê°€ì‹œì„± ì²´í¬:', {
      totalNodes: positionedFeeds.length,
      visibleNodes: visible.length,
      viewport: { start: viewportStart, end: viewportEnd },
      nodeYRange: positionedFeeds.length > 0 ? {
        min: Math.min(...positionedFeeds.map(f => f.branchPosition.y || 0)),
        max: Math.max(...positionedFeeds.map(f => f.branchPosition.y || 0))
      } : { min: 0, max: 0 }
    });

    console.log(`ğŸ“Š ê°€ì‹œ ë…¸ë“œ: ${visible.length}/${positionedFeeds.length}`);

    return visible;
  }, [positionedFeeds, viewportState, stagePositions, feeds]);

  // ë…¸ë“œ í´ë¦­ í•¸ë“¤ëŸ¬
  const handleNodeClick = useCallback((feed: FeedItemWithPosition, event: React.MouseEvent) => {
    event.stopPropagation();

    const interactionEvent: BranchInteractionEvent = {
      type: 'select',
      feedId: feed.id,
      timestamp: new Date(),
      mousePosition: {
        x: event.clientX,
        y: event.clientY
      }
    };

    onFeedInteraction(interactionEvent);
  }, [onFeedInteraction]);

  // ë…¸ë“œ í˜¸ë²„ í•¸ë“¤ëŸ¬
  const handleNodeHover = useCallback((feed: FeedItemWithPosition | null, event?: React.MouseEvent) => {
    if (feed) {
      const interactionEvent: BranchInteractionEvent = {
        type: 'hover',
        feedId: feed.id,
        timestamp: new Date(),
        mousePosition: event ? {
          x: event.clientX,
          y: event.clientY
        } : undefined
      };
      onFeedInteraction(interactionEvent);
    }
  }, [onFeedInteraction]);

  // ë…¸ë“œ í™•ì¥/ì¶•ì†Œ í•¸ë“¤ëŸ¬
  const handleNodeToggle = useCallback((feed: FeedItemWithPosition) => {
    const isExpanded = expandedFeedIds.has(feed.id);

    const interactionEvent: BranchInteractionEvent = {
      type: isExpanded ? 'collapse' : 'expand',
      feedId: feed.id,
        timestamp: new Date()
      };
      onFeedInteraction(interactionEvent);
  }, [expandedFeedIds, onFeedInteraction]);

  // ë ˆì´ì–´ ìŠ¤íƒ€ì¼
  const layerStyle: React.CSSProperties = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    pointerEvents: 'auto',
    zIndex: 3
  };

  return (
    <div className="node-layer" style={layerStyle}>
      {visibleNodes.map(feed => (
        <BranchNode
          key={feed.id}
          feed={feed}
          isHovered={state.ui.hoveredFeedId === feed.id}
          isSelected={state.ui.selectedFeedId === feed.id}
          isExpanded={state.ui.expandedFeedIds.has(feed.id)}
          viewMode={state.ui.viewMode}
          onHover={handleNodeHover}
          onClick={handleNodeClick}
          onToggle={handleNodeToggle}
        />
      ))}
    </div>
  );
};

/**
 * ê°œë³„ ë¸Œëœì¹˜ ë…¸ë“œ ì»´í¬ë„ŒíŠ¸
 */
interface BranchNodeProps {
  feed: FeedItemWithPosition;
  isHovered: boolean;
  isSelected: boolean;
  isExpanded: boolean;
  viewMode: 'normal' | 'compact' | 'detailed';
  onHover: (feed: FeedItemWithPosition | null) => void;
  onClick: (feed: FeedItemWithPosition, event: React.MouseEvent) => void;
  onToggle: (feed: FeedItemWithPosition) => void;
}

const BranchNode: React.FC<BranchNodeProps> = React.memo(({
  feed,
  isHovered,
  isSelected,
  isExpanded,
  viewMode,
  onHover,
  onClick,
  onToggle
}) => {
  // ë…¸ë“œ ìœ„ì¹˜ ê³„ì‚°
  const nodeStyle: React.CSSProperties = useMemo(() => {
    const { x, y } = feed.branchPosition;

    return {
      position: 'absolute',
      left: `${x}px`,
      top: `${y}px`,
      transform: 'translate(-50%, -50%)',
      zIndex: isSelected ? 10 : isHovered ? 5 : 1,
      transition: 'all 0.2s ease',
      cursor: 'pointer'
    };
  }, [feed.branchPosition, isSelected, isHovered]);

  // ë…¸ë“œ í¬ê¸° ë° ìŠ¤íƒ€ì¼ ê³„ì‚°
  const nodeConfig = useMemo(() => {
    const baseWidth = viewMode === 'compact' ? 180 : viewMode === 'detailed' ? 280 : 220;
    const baseHeight = viewMode === 'compact' ? 36 : viewMode === 'detailed' ? 60 : 44;

    const expandedWidth = isExpanded ? Math.min(400, baseWidth * 1.8) : baseWidth;
    const expandedHeight = isExpanded ? baseHeight * 1.5 : baseHeight;

    return {
      width: expandedWidth,
      height: expandedHeight,
      scale: isHovered ? 1.05 : 1
    };
  }, [viewMode, isExpanded, isHovered]);

  // í”¼ë“œ íƒ€ì…ë³„ ì•„ì´ì½˜
  const getTypeIcon = (type: string): string => {
    switch (type) {
      case 'file': return 'ğŸ“„';
      case 'meeting': return 'ğŸ¤';
      case 'comment': return 'ğŸ’¬';
      case 'todo': return 'âœ…';
      case 'progress': return 'ğŸ“Š';
      case 'team': return 'ğŸ‘¥';
      default: return 'ğŸ“‹';
    }
  };

  // ìš°ì„ ìˆœìœ„ë³„ ìƒ‰ìƒ
  const getPriorityColor = (priority: string): string => {
    switch (priority) {
      case 'high': return '#EF4444';
      case 'medium': return '#F59E0B';
      case 'low': return '#10B981';
      default: return '#6B7280';
    }
  };

  // ë…¸ë“œ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼
  const containerStyle: React.CSSProperties = {
    width: `${nodeConfig.width}px`,
    height: `${nodeConfig.height}px`,
    transform: `scale(${nodeConfig.scale})`,
    borderRadius: '12px',
    background: isSelected
      ? 'linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%)'
      : isHovered
      ? 'linear-gradient(135deg, #F8FAFC 0%, #E2E8F0 100%)'
      : 'linear-gradient(135deg, #FFFFFF 0%, #F1F5F9 100%)',
    border: isSelected
      ? '2px solid #2563EB'
      : isHovered
      ? '2px solid #CBD5E1'
      : '1px solid #E2E8F0',
    boxShadow: isSelected
      ? '0 10px 25px rgba(59, 130, 246, 0.3)'
      : isHovered
      ? '0 8px 20px rgba(0, 0, 0, 0.12)'
      : '0 4px 12px rgba(0, 0, 0, 0.08)',
    color: isSelected ? '#FFFFFF' : '#1F2937',
    overflow: 'hidden',
    display: 'flex',
    flexDirection: 'column',
    transition: 'all 0.2s ease'
  };

  // íˆ´íŒ ìƒíƒœ
  const [showTooltip, setShowTooltip] = React.useState(false);
  const [tooltipPosition, setTooltipPosition] = React.useState({ x: 0, y: 0 });

  const handleMouseEnter = (e: React.MouseEvent) => {
    onHover(feed, e);
    setShowTooltip(true);
    const rect = e.currentTarget.getBoundingClientRect();
    setTooltipPosition({
      x: rect.left + rect.width / 2,
      y: rect.top - 10
    });
  };

  const handleMouseLeave = () => {
    onHover(null);
    setShowTooltip(false);
  };

  return (
    <div
      style={nodeStyle}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      onClick={(e) => onClick(feed, e)}
      data-feed-id={feed.id}
      data-timeline-node
      data-hovered={isHovered}
      data-selected={isSelected}
      data-expanded={isExpanded}
    >
      <div style={containerStyle}>
        {/* í—¤ë” ì˜ì—­ */}
        <div style={{
          display: 'flex',
          alignItems: 'center',
          padding: viewMode === 'compact' ? '8px 12px' : '12px 16px',
          borderBottom: isExpanded ? `1px solid ${isSelected ? 'rgba(255,255,255,0.2)' : '#E2E8F0'}` : 'none'
        }}>
          {/* íƒ€ì… ì•„ì´ì½˜ */}
          <span style={{
            fontSize: viewMode === 'compact' ? '14px' : '16px',
            marginRight: '8px'
          }}>
            {getTypeIcon(feed.type)}
          </span>

          {/* ì œëª© */}
          <span style={{
            flex: 1,
            fontSize: viewMode === 'compact' ? '12px' : '14px',
            fontWeight: '600',
            truncate: true,
            whiteSpace: 'nowrap',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
          }}>
            {feed.title}
          </span>

          {/* ìš°ì„ ìˆœìœ„ ì¸ë””ì¼€ì´í„° */}
          <div style={{
            width: '8px',
            height: '8px',
            borderRadius: '50%',
            backgroundColor: getPriorityColor(feed.priority),
            marginLeft: '8px'
          }} />

          {/* í™•ì¥/ì¶•ì†Œ ë²„íŠ¼ */}
          <button
            onClick={(e) => {
              e.stopPropagation();
              onToggle(feed);
            }}
            style={{
              marginLeft: '8px',
              background: 'none',
              border: 'none',
              color: 'inherit',
              cursor: 'pointer',
              fontSize: '12px',
              opacity: 0.7,
              transition: 'opacity 0.2s ease'
            }}
          >
            {isExpanded ? 'âˆ’' : '+'}
          </button>
        </div>

        {/* í™•ì¥ëœ ë‚´ìš© ì˜ì—­ */}
        {isExpanded && (
          <div style={{
            padding: '12px 16px',
            fontSize: '12px',
            opacity: 0.8,
            lineHeight: '1.4'
          }}>
            {feed.description && (
              <p style={{ margin: '0 0 8px 0' }}>
                {feed.description.length > 100
                  ? `${feed.description.substring(0, 100)}...`
                  : feed.description
                }
              </p>
            )}
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              fontSize: '10px',
              opacity: 0.6
            }}>
              <span>{feed.author?.name}</span>
              <span>{new Date(feed.timestamp).toLocaleDateString()}</span>
            </div>
          </div>
        )}
      </div>

      {/* íˆ´íŒ */}
      {showTooltip && !isExpanded && (
        <div
          style={{
            position: 'fixed',
            left: `${tooltipPosition.x}px`,
            top: `${tooltipPosition.y}px`,
            transform: 'translate(-50%, -100%)',
            background: 'rgba(0, 0, 0, 0.9)',
            color: 'white',
            padding: '8px 12px',
            borderRadius: '6px',
            fontSize: '12px',
            zIndex: 1000,
            pointerEvents: 'none',
            whiteSpace: 'nowrap',
            maxWidth: '300px',
            animation: 'fadeIn 0.2s ease'
          }}
        >
          <div style={{ fontWeight: 'bold', marginBottom: '4px' }}>
            {feed.title}
          </div>
          <div style={{ opacity: 0.8, fontSize: '11px' }}>
            {new Date(feed.timestamp).toLocaleDateString('ko-KR')} â€¢ {feed.type}
          </div>
          {feed.description && (
            <div style={{
              opacity: 0.7,
              fontSize: '11px',
              marginTop: '4px',
              whiteSpace: 'normal',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              display: '-webkit-box',
              WebkitLineClamp: 2,
              WebkitBoxOrient: 'vertical'
            }}>
              {feed.description}
            </div>
          )}
        </div>
      )}
    </div>
  );
});

BranchNode.displayName = 'BranchNode';

export default NodeLayer;