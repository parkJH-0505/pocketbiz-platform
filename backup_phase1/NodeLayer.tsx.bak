/**
 * @fileoverview 인터랙티브 노드 레이어
 * @description 브랜치 끝의 피드 노드들과 인터랙션 처리
 * @author PocketCompany
 * @since 2025-01-20
 */

import React, { useMemo, useCallback, useRef, useEffect } from 'react';
import type { FeedItem } from '../../types/timeline.types';
import type {
  StagePosition,
  BranchInteractionEvent,
  FeedItemWithPosition
} from '../../types/branch-timeline.types';
import type { ProjectPhase } from '../../types/buildup.types';
import { BRANCH_CONFIGURATIONS } from '../../config/branchPositions';

interface NodeLayerProps {
  /** 피드 데이터 */
  feeds: FeedItem[];
  /** 위치가 계산된 피드 데이터 */
  positionedFeeds: FeedItemWithPosition[];
  /** 브랜치 시작점들 */
  branchStartPoints: Record<ProjectPhase, { x: number; y: number }>;
  /** 뷰포트 상태 */
  viewportState: {
    width: number;
    height: number;
    scrollTop: number;
    scrollLeft: number;
  };
  /** 단계 위치 정보 */
  stagePositions: Record<ProjectPhase, StagePosition>;
  /** 피드 인터랙션 핸들러 */
  onFeedInteraction: (event: BranchInteractionEvent) => void;
  /** 컨테이너 참조 */
  containerRef: React.RefObject<HTMLDivElement>;
  /** 호버된 피드 ID */
  hoveredFeedId: string | null;
  /** 선택된 피드 ID */
  selectedFeedId: string | null;
  /** 확장된 피드 IDs */
  expandedFeedIds: Set<string>;
}

/**
 * 인터랙티브 노드 레이어
 * 브랜치 끝에 위치한 피드 노드들의 렌더링과 인터랙션 관리
 */
const NodeLayer: React.FC<NodeLayerProps> = ({
  feeds,
  positionedFeeds,
  branchStartPoints,
  viewportState,
  stagePositions,
  onFeedInteraction,
  containerRef,
  hoveredFeedId,
  selectedFeedId,
  expandedFeedIds
}) => {

  // 컴포넌트 리렌더링 추적
  const renderCount = useRef(0);
  const prevFeedsCount = useRef(positionedFeeds.length);

  useEffect(() => {
    renderCount.current++;
    console.log('🎨 NodeLayer 렌더링:', {
      renderCount: renderCount.current,
      positionedFeedsCount: positionedFeeds.length,
      feedsFromProps: feeds.length,
      feedsChanged: prevFeedsCount.current !== positionedFeeds.length,
      timestamp: new Date().toISOString()
    });

    prevFeedsCount.current = positionedFeeds.length;
  });

  // 현재 뷰포트에 보이는 노드들만 계산
  const visibleNodes: FeedItemWithPosition[] = useMemo(() => {
    // 디버깅: feedsWithPositions 확인
    console.log('🔍 NodeLayer - positionedFeeds:', {
      count: positionedFeeds.length,
      feeds: positionedFeeds,
      stagePositions: stagePositions,
      rawFeeds: feeds
    });

    // Props에서 받은 위치 데이터 사용
    if (positionedFeeds.length > 0) {
      console.log('✅ Props에서 위치 데이터 사용:', {
        count: positionedFeeds.length,
        firstNode: positionedFeeds[0]?.branchPosition,
        allPositions: positionedFeeds.map(f => ({
          title: f.title,
          x: f.branchPosition.x,
          y: f.branchPosition.y
        }))
      });
    } else if (feeds.length > 0) {
      console.warn('⚠️ 위치 데이터가 없음. feeds:', feeds.length);
    }

    const { scrollTop, height } = viewportState;
    const viewportStart = scrollTop - 100; // 오버스캔
    const viewportEnd = scrollTop + height + 100;

    // 디버깅: 뷰포트 및 노드 위치 확인
    console.log('📐 뷰포트 계산:', {
      scrollTop,
      height,
      viewportStart,
      viewportEnd,
      firstNodeY: positionedFeeds[0]?.branchPosition?.y,
      lastNodeY: positionedFeeds[positionedFeeds.length - 1]?.branchPosition?.y
    });

    // 뷰포트 내 노드 필터링 - 일시적으로 모든 노드 표시 (디버깅)
    const visible = positionedFeeds; // 모든 노드 표시하여 위치 확인

    console.log('🔍 노드 가시성 체크:', {
      totalNodes: positionedFeeds.length,
      visibleNodes: visible.length,
      viewport: { start: viewportStart, end: viewportEnd },
      nodeYRange: positionedFeeds.length > 0 ? {
        min: Math.min(...positionedFeeds.map(f => f.branchPosition.y || 0)),
        max: Math.max(...positionedFeeds.map(f => f.branchPosition.y || 0))
      } : { min: 0, max: 0 }
    });

    console.log(`📊 가시 노드: ${visible.length}/${positionedFeeds.length}`);

    return visible;
  }, [positionedFeeds, viewportState, stagePositions, feeds]);

  // 노드 클릭 핸들러
  const handleNodeClick = useCallback((feed: FeedItemWithPosition, event: React.MouseEvent) => {
    event.stopPropagation();

    const interactionEvent: BranchInteractionEvent = {
      type: 'select',
      feedId: feed.id,
      timestamp: new Date(),
      mousePosition: {
        x: event.clientX,
        y: event.clientY
      }
    };

    onFeedInteraction(interactionEvent);
  }, [onFeedInteraction]);

  // 노드 호버 핸들러
  const handleNodeHover = useCallback((feed: FeedItemWithPosition | null, event?: React.MouseEvent) => {
    if (feed) {
      const interactionEvent: BranchInteractionEvent = {
        type: 'hover',
        feedId: feed.id,
        timestamp: new Date(),
        mousePosition: event ? {
          x: event.clientX,
          y: event.clientY
        } : undefined
      };
      onFeedInteraction(interactionEvent);
    }
  }, [onFeedInteraction]);

  // 노드 확장/축소 핸들러
  const handleNodeToggle = useCallback((feed: FeedItemWithPosition) => {
    const isExpanded = expandedFeedIds.has(feed.id);

    const interactionEvent: BranchInteractionEvent = {
      type: isExpanded ? 'collapse' : 'expand',
      feedId: feed.id,
        timestamp: new Date()
      };
      onFeedInteraction(interactionEvent);
  }, [expandedFeedIds, onFeedInteraction]);

  // 레이어 스타일
  const layerStyle: React.CSSProperties = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    pointerEvents: 'auto',
    zIndex: 3
  };

  return (
    <div className="node-layer" style={layerStyle}>
      {visibleNodes.map(feed => (
        <BranchNode
          key={feed.id}
          feed={feed}
          isHovered={state.ui.hoveredFeedId === feed.id}
          isSelected={state.ui.selectedFeedId === feed.id}
          isExpanded={state.ui.expandedFeedIds.has(feed.id)}
          viewMode={state.ui.viewMode}
          onHover={handleNodeHover}
          onClick={handleNodeClick}
          onToggle={handleNodeToggle}
        />
      ))}
    </div>
  );
};

/**
 * 개별 브랜치 노드 컴포넌트
 */
interface BranchNodeProps {
  feed: FeedItemWithPosition;
  isHovered: boolean;
  isSelected: boolean;
  isExpanded: boolean;
  viewMode: 'normal' | 'compact' | 'detailed';
  onHover: (feed: FeedItemWithPosition | null) => void;
  onClick: (feed: FeedItemWithPosition, event: React.MouseEvent) => void;
  onToggle: (feed: FeedItemWithPosition) => void;
}

const BranchNode: React.FC<BranchNodeProps> = React.memo(({
  feed,
  isHovered,
  isSelected,
  isExpanded,
  viewMode,
  onHover,
  onClick,
  onToggle
}) => {
  // 노드 위치 계산
  const nodeStyle: React.CSSProperties = useMemo(() => {
    const { x, y } = feed.branchPosition;

    return {
      position: 'absolute',
      left: `${x}px`,
      top: `${y}px`,
      transform: 'translate(-50%, -50%)',
      zIndex: isSelected ? 10 : isHovered ? 5 : 1,
      transition: 'all 0.2s ease',
      cursor: 'pointer'
    };
  }, [feed.branchPosition, isSelected, isHovered]);

  // 노드 크기 및 스타일 계산
  const nodeConfig = useMemo(() => {
    const baseWidth = viewMode === 'compact' ? 180 : viewMode === 'detailed' ? 280 : 220;
    const baseHeight = viewMode === 'compact' ? 36 : viewMode === 'detailed' ? 60 : 44;

    const expandedWidth = isExpanded ? Math.min(400, baseWidth * 1.8) : baseWidth;
    const expandedHeight = isExpanded ? baseHeight * 1.5 : baseHeight;

    return {
      width: expandedWidth,
      height: expandedHeight,
      scale: isHovered ? 1.05 : 1
    };
  }, [viewMode, isExpanded, isHovered]);

  // 피드 타입별 아이콘
  const getTypeIcon = (type: string): string => {
    switch (type) {
      case 'file': return '📄';
      case 'meeting': return '🤝';
      case 'comment': return '💬';
      case 'todo': return '✅';
      case 'progress': return '📊';
      case 'team': return '👥';
      default: return '📋';
    }
  };

  // 우선순위별 색상
  const getPriorityColor = (priority: string): string => {
    switch (priority) {
      case 'high': return '#EF4444';
      case 'medium': return '#F59E0B';
      case 'low': return '#10B981';
      default: return '#6B7280';
    }
  };

  // 노드 컨테이너 스타일
  const containerStyle: React.CSSProperties = {
    width: `${nodeConfig.width}px`,
    height: `${nodeConfig.height}px`,
    transform: `scale(${nodeConfig.scale})`,
    borderRadius: '12px',
    background: isSelected
      ? 'linear-gradient(135deg, #3B82F6 0%, #1D4ED8 100%)'
      : isHovered
      ? 'linear-gradient(135deg, #F8FAFC 0%, #E2E8F0 100%)'
      : 'linear-gradient(135deg, #FFFFFF 0%, #F1F5F9 100%)',
    border: isSelected
      ? '2px solid #2563EB'
      : isHovered
      ? '2px solid #CBD5E1'
      : '1px solid #E2E8F0',
    boxShadow: isSelected
      ? '0 10px 25px rgba(59, 130, 246, 0.3)'
      : isHovered
      ? '0 8px 20px rgba(0, 0, 0, 0.12)'
      : '0 4px 12px rgba(0, 0, 0, 0.08)',
    color: isSelected ? '#FFFFFF' : '#1F2937',
    overflow: 'hidden',
    display: 'flex',
    flexDirection: 'column',
    transition: 'all 0.2s ease'
  };

  // 툴팁 상태
  const [showTooltip, setShowTooltip] = React.useState(false);
  const [tooltipPosition, setTooltipPosition] = React.useState({ x: 0, y: 0 });

  const handleMouseEnter = (e: React.MouseEvent) => {
    onHover(feed, e);
    setShowTooltip(true);
    const rect = e.currentTarget.getBoundingClientRect();
    setTooltipPosition({
      x: rect.left + rect.width / 2,
      y: rect.top - 10
    });
  };

  const handleMouseLeave = () => {
    onHover(null);
    setShowTooltip(false);
  };

  return (
    <div
      style={nodeStyle}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      onClick={(e) => onClick(feed, e)}
      data-feed-id={feed.id}
      data-timeline-node
      data-hovered={isHovered}
      data-selected={isSelected}
      data-expanded={isExpanded}
    >
      <div style={containerStyle}>
        {/* 헤더 영역 */}
        <div style={{
          display: 'flex',
          alignItems: 'center',
          padding: viewMode === 'compact' ? '8px 12px' : '12px 16px',
          borderBottom: isExpanded ? `1px solid ${isSelected ? 'rgba(255,255,255,0.2)' : '#E2E8F0'}` : 'none'
        }}>
          {/* 타입 아이콘 */}
          <span style={{
            fontSize: viewMode === 'compact' ? '14px' : '16px',
            marginRight: '8px'
          }}>
            {getTypeIcon(feed.type)}
          </span>

          {/* 제목 */}
          <span style={{
            flex: 1,
            fontSize: viewMode === 'compact' ? '12px' : '14px',
            fontWeight: '600',
            truncate: true,
            whiteSpace: 'nowrap',
            overflow: 'hidden',
            textOverflow: 'ellipsis'
          }}>
            {feed.title}
          </span>

          {/* 우선순위 인디케이터 */}
          <div style={{
            width: '8px',
            height: '8px',
            borderRadius: '50%',
            backgroundColor: getPriorityColor(feed.priority),
            marginLeft: '8px'
          }} />

          {/* 확장/축소 버튼 */}
          <button
            onClick={(e) => {
              e.stopPropagation();
              onToggle(feed);
            }}
            style={{
              marginLeft: '8px',
              background: 'none',
              border: 'none',
              color: 'inherit',
              cursor: 'pointer',
              fontSize: '12px',
              opacity: 0.7,
              transition: 'opacity 0.2s ease'
            }}
          >
            {isExpanded ? '−' : '+'}
          </button>
        </div>

        {/* 확장된 내용 영역 */}
        {isExpanded && (
          <div style={{
            padding: '12px 16px',
            fontSize: '12px',
            opacity: 0.8,
            lineHeight: '1.4'
          }}>
            {feed.description && (
              <p style={{ margin: '0 0 8px 0' }}>
                {feed.description.length > 100
                  ? `${feed.description.substring(0, 100)}...`
                  : feed.description
                }
              </p>
            )}
            <div style={{
              display: 'flex',
              justifyContent: 'space-between',
              fontSize: '10px',
              opacity: 0.6
            }}>
              <span>{feed.author?.name}</span>
              <span>{new Date(feed.timestamp).toLocaleDateString()}</span>
            </div>
          </div>
        )}
      </div>

      {/* 툴팁 */}
      {showTooltip && !isExpanded && (
        <div
          style={{
            position: 'fixed',
            left: `${tooltipPosition.x}px`,
            top: `${tooltipPosition.y}px`,
            transform: 'translate(-50%, -100%)',
            background: 'rgba(0, 0, 0, 0.9)',
            color: 'white',
            padding: '8px 12px',
            borderRadius: '6px',
            fontSize: '12px',
            zIndex: 1000,
            pointerEvents: 'none',
            whiteSpace: 'nowrap',
            maxWidth: '300px',
            animation: 'fadeIn 0.2s ease'
          }}
        >
          <div style={{ fontWeight: 'bold', marginBottom: '4px' }}>
            {feed.title}
          </div>
          <div style={{ opacity: 0.8, fontSize: '11px' }}>
            {new Date(feed.timestamp).toLocaleDateString('ko-KR')} • {feed.type}
          </div>
          {feed.description && (
            <div style={{
              opacity: 0.7,
              fontSize: '11px',
              marginTop: '4px',
              whiteSpace: 'normal',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              display: '-webkit-box',
              WebkitLineClamp: 2,
              WebkitBoxOrient: 'vertical'
            }}>
              {feed.description}
            </div>
          )}
        </div>
      )}
    </div>
  );
});

BranchNode.displayName = 'BranchNode';

export default NodeLayer;