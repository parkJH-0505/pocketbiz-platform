/**
 * @fileoverview ë¸Œëœì¹˜ ì—°ê²°ì„  ë ˆì´ì–´
 * @description SVG ê¸°ë°˜ ë¸Œëœì¹˜ ë Œë”ë§ ë° ì• ë‹ˆë©”ì´ì…˜
 * @author PocketCompany
 * @since 2025-01-20
 */

import React, { useMemo, useRef, useEffect } from 'react';
import type { FeedItem } from '../../types/timeline.types';
import type {
  StagePosition,
  BranchConnector
} from '../../types/branch-timeline.types';
import type { ProjectPhase } from '../../types/buildup.types';

interface BranchLayerProps {
  /** í”¼ë“œ ë°ì´í„° */
  feeds: FeedItem[];
  /** ë¸Œëœì¹˜ ì—°ê²°ì„  ë°ì´í„° */
  branchConnectors: BranchConnector[];
  /** ë¸Œëœì¹˜ ì‹œì‘ì ë“¤ */
  branchStartPoints: Record<ProjectPhase, { x: number; y: number }>;
  /** ë·°í¬íŠ¸ ìƒíƒœ */
  viewportState: {
    width: number;
    height: number;
    scrollTop: number;
    scrollLeft: number;
  };
  /** ë‹¨ê³„ ìœ„ì¹˜ ì •ë³´ */
  stagePositions: Record<ProjectPhase, StagePosition>;
  /** ì»¨í…Œì´ë„ˆ ì°¸ì¡° */
  containerRef: React.RefObject<HTMLDivElement>;
}

/**
 * SVG ë¸Œëœì¹˜ ì—°ê²°ì„  ë ˆì´ì–´
 * ë©”ì¸ íƒ€ì„ë¼ì¸ì—ì„œ ê° í”¼ë“œ ë…¸ë“œë¡œ ì—°ê²°ë˜ëŠ” ë¸Œëœì¹˜ë“¤ì„ ë Œë”ë§
 */
const BranchLayer: React.FC<BranchLayerProps> = ({
  feeds,
  branchConnectors,
  branchStartPoints,
  viewportState,
  stagePositions,
  containerRef
}) => {

  // ì»´í¬ë„ŒíŠ¸ ë¦¬ë Œë”ë§ ì¶”ì 
  const renderCount = useRef(0);
  const prevConnectorsCount = useRef(branchConnectors.length);

  useEffect(() => {
    renderCount.current++;
    console.log('ğŸ¨ BranchLayer ë Œë”ë§:', {
      renderCount: renderCount.current,
      connectorsFromProps: branchConnectors.length,
      feedsFromProps: feeds.length,
      connectorsChanged: prevConnectorsCount.current !== branchConnectors.length,
      timestamp: new Date().toISOString()
    });

    prevConnectorsCount.current = branchConnectors.length;
  });

  // í˜„ì¬ ë·°í¬íŠ¸ì— ë³´ì´ëŠ” ë¸Œëœì¹˜ ì—°ê²°ì„ ë“¤ë§Œ ê³„ì‚°
  const visibleConnectors: BranchConnector[] = useMemo(() => {
    console.log('ğŸ” BranchLayer - branchConnectors:', {
      count: branchConnectors.length,
      connectors: branchConnectors,
      feeds: feeds,
      sampleConnector: branchConnectors[0]
    });

    const { scrollTop, height } = viewportState;
    const viewportStart = scrollTop - 100; // ì˜¤ë²„ìŠ¤ìº”
    const viewportEnd = scrollTop + height + 100;

    // Propsì—ì„œ ë°›ì€ ì—°ê²°ì„  ì‚¬ìš© - ì¼ì‹œì ìœ¼ë¡œ ëª¨ë“  ì—°ê²°ì„  í‘œì‹œ (ë””ë²„ê¹…)
    let connectors: BranchConnector[] = branchConnectors; // í•„í„°ë§ ë¹„í™œì„±í™”

    // ë””ë²„ê¹…: ì—°ê²°ì„  ë°ì´í„° í™•ì¸
    if (branchConnectors.length > 0) {
      console.log('âœ… ì—°ê²°ì„  ë°ì´í„° ì‚¬ìš©:', {
        total: branchConnectors.length,
        visible: connectors.length,
        firstConnectorPath: connectors[0]?.pathData
      });
    } else if (feeds.length > 0) {
      console.warn('âš ï¸ ì—°ê²°ì„  ë°ì´í„°ê°€ ì—†ìŒ. feeds:', feeds.length);
      // ì§ì ‘ ê°„ë‹¨í•œ ì—°ê²°ì„  ìƒì„± (ì„ì‹œ) - ë” ëˆˆì— ë„ê²Œ
      const colors = ['#FF0000', '#00FF00', '#0000FF', '#FF00FF', '#FFFF00'];
      connectors = feeds.slice(0, 5).map((feed, index) => ({
        id: `temp-connector-${index}`,
        startPoint: { x: 0, y: 200 + (index * 80) },
        endPoint: { x: 200 + (index * 30), y: 200 + (index * 80) },
        style: {
          color: colors[index] || '#3B82F6',
          secondaryColor: '#DBEAFE',
          strokeWidth: 4, // ë” ë‘ê»ê²Œ
          branchType: 'curved' as const,
          iconSize: 'medium' as const,
          priority: 1,
          offsetX: 0,
          animation: {
            enableDrawAnimation: true,
            duration: 800,
            easing: 'ease-out'
          }
        },
        animationState: 'idle' as const,
        pathData: `M 0 ${200 + (index * 80)} L ${200 + (index * 30)} ${200 + (index * 80)}`, // ë‹¨ìˆœí•œ ì§ì„ 
        feedId: feed.id
      }));
      console.log('ğŸ”§ ì„ì‹œ ì—°ê²°ì„  ìƒì„±:', connectors);
    }

    return connectors;
  }, [branchConnectors, feeds, viewportState]);

  // SVG ë·°ë°•ìŠ¤ ê³„ì‚°
  const svgViewBox = useMemo(() => {
    // ì˜¤ë¥¸ìª½ ì˜ì—­ í¬ê¸°ì— ë§ì¶¤ (ì¢Œí‘œê³„ë¥¼ ì‹¤ì œ ë Œë”ë§ ì˜ì—­ì— ë§¤í•‘)
    return `0 0 800 1200`; // ê³ ì • í¬ê¸°ë¡œ ì„¤ì •
  }, []);

  // ìŠ¤íƒ€ì¼ ì„¤ì •
  const layerStyle: React.CSSProperties = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    pointerEvents: 'none',
    zIndex: 2,
    overflow: 'hidden'
  };

  const svgStyle: React.CSSProperties = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    pointerEvents: 'none',
    minHeight: '2000px' // Ensure minimum height for visibility
  };

  return (
    <div className="branch-layer" style={layerStyle}>
      <svg
        style={svgStyle}
        viewBox={svgViewBox}
        preserveAspectRatio="none"
        data-testid="branch-svg"
      >
        {/* ì •ì˜ ì„¹ì…˜ - ê·¸ë¼ë°ì´ì…˜, íŒ¨í„´ ë“± */}
        <defs>
          {/* ë¸Œëœì¹˜ë³„ ê·¸ë¼ë°ì´ì…˜ ì •ì˜ */}
          {visibleConnectors.map(connector => (
            <linearGradient
              key={`gradient-${connector.id}`}
              id={`branch-gradient-${connector.id}`}
              x1="0%"
              y1="0%"
              x2="100%"
              y2="0%"
            >
              <stop
                offset="0%"
                stopColor={connector.style.color}
                stopOpacity="0.1"
              />
              <stop
                offset="100%"
                stopColor={connector.style.color}
                stopOpacity="0.8"
              />
            </linearGradient>
          ))}

          {/* ì• ë‹ˆë©”ì´ì…˜ íŒ¨í„´ */}
          <pattern
            id="branch-animation-pattern"
            patternUnits="userSpaceOnUse"
            width="10"
            height="2"
          >
            <rect
              width="5"
              height="2"
              fill="currentColor"
              opacity="0.3"
            />
          </pattern>
        </defs>

        {/* ë¸Œëœì¹˜ ì—°ê²°ì„ ë“¤ ë Œë”ë§ */}
        <g className="branch-connectors">
          {/* ì‹¤ì œ ì—°ê²°ì„ ë“¤ */}
          {visibleConnectors.length > 0 ? (
            visibleConnectors.map(connector => (
              <BranchConnectorPath
                key={connector.id}
                connector={connector}
              />
            ))
          ) : (
            // ì—°ê²°ì„ ì´ ì—†ì„ ë•Œ ê¸°ë³¸ í‘œì‹œ
            <>
              <path
                d="M 0 100 L 200 100"
                stroke="#FF0000"
                strokeWidth="3"
                fill="none"
              />
              <text x="10" y="90" fill="#FF0000" fontSize="12">
                No connectors found
              </text>
            </>
          )}
        </g>

        {/* ë””ë²„ê·¸ ëª¨ë“œìš© ê·¸ë¦¬ë“œ ë¼ì¸ (ê°œë°œ ì‹œì—ë§Œ) */}
        {process.env.NODE_ENV === 'development' && (
          <g className="debug-grid" opacity="0.1">
            {/* ìˆ˜ì§ ê·¸ë¦¬ë“œ ë¼ì¸ë“¤ */}
            {Array.from({ length: 10 }, (_, i) => (
              <line
                key={`vgrid-${i}`}
                x1={i * 50}
                y1={viewportState.scrollTop}
                x2={i * 50}
                y2={viewportState.scrollTop + viewportState.height}
                stroke="#999"
                strokeWidth="0.5"
              />
            ))}
            {/* ìˆ˜í‰ ê·¸ë¦¬ë“œ ë¼ì¸ë“¤ */}
            {Array.from({ length: 20 }, (_, i) => (
              <line
                key={`hgrid-${i}`}
                x1={0}
                y1={viewportState.scrollTop + i * 50}
                x2={viewportState.width}
                y2={viewportState.scrollTop + i * 50}
                stroke="#999"
                strokeWidth="0.5"
              />
            ))}
          </g>
        )}
      </svg>
    </div>
  );
};

/**
 * ê°œë³„ ë¸Œëœì¹˜ ì—°ê²°ì„  ì»´í¬ë„ŒíŠ¸
 */
interface BranchConnectorPathProps {
  connector: BranchConnector;
}

const BranchConnectorPath: React.FC<BranchConnectorPathProps> = React.memo(({ connector }) => {
  const { style, pathData, animationState, id } = connector;

  // ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ê³„ì‚°
  const animationClass = useMemo(() => {
    switch (animationState) {
      case 'drawing':
        return 'branch-drawing';
      case 'pulsing':
        return 'branch-pulsing';
      case 'fading':
        return 'branch-fading';
      default:
        return '';
    }
  }, [animationState]);

  // ìŠ¤íŠ¸ë¡œí¬ ëŒ€ì‹œ ë°°ì—´ (ì• ë‹ˆë©”ì´ì…˜ìš©)
  const strokeDashArray = useMemo(() => {
    if (animationState === 'drawing') {
      // íŒ¨ìŠ¤ ê¸¸ì´ ê¸°ë°˜ ëŒ€ì‹œ ì„¤ì •
      return '5,5';
    }
    return undefined;
  }, [animationState]);

  // ë””ë²„ê¹…: íŒ¨ìŠ¤ ë°ì´í„° í™•ì¸
  console.log(`ğŸ¨ Rendering connector ${id}:`, {
    pathData: pathData.substring(0, 100),
    color: style.color,
    strokeWidth: style.strokeWidth
  });

  return (
    <g className={`branch-connector ${animationClass}`}>
      {/* ë©”ì¸ ë¸Œëœì¹˜ ë¼ì¸ - ë” ëˆˆì— ë„ê²Œ */}
      <path
        d={pathData}
        stroke={style.color || '#FF0000'}
        strokeWidth={style.strokeWidth * 2 || 4}
        fill="none"
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeDasharray={strokeDashArray}
        opacity={1}
        style={{
          filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))'
        }}
      />

      {/* ë°°ê²½ ë¸Œëœì¹˜ (ë” ë‘êº¼ìš´ ë¼ì¸) */}
      <path
        d={pathData}
        stroke={style.secondaryColor}
        strokeWidth={style.strokeWidth + 1}
        fill="none"
        strokeLinecap="round"
        strokeLinejoin="round"
        opacity={0.3}
        style={{
          filter: 'blur(1px)'
        }}
      />

      {/* í•˜ì´ë¼ì´íŠ¸ íš¨ê³¼ (í˜¸ë²„ ì‹œ) */}
      <path
        d={pathData}
        stroke="url(#branch-gradient-${id})"
        strokeWidth={style.strokeWidth * 1.5}
        fill="none"
        strokeLinecap="round"
        strokeLinejoin="round"
        opacity={0}
        className="branch-highlight"
        style={{
          transition: 'opacity 0.2s ease'
        }}
      />
    </g>
  );
});

BranchConnectorPath.displayName = 'BranchConnectorPath';

export default BranchLayer;